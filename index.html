<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostGIS Multi-Layer Viewer (Optimized)</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css' rel='stylesheet' />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .input-panel {
            width: 450px;
            background: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #e0e0e0;
        }

        .layer-section {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
        }

        .layer-section.active {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .layer-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .layer-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid white;
            box-shadow: 0 0 0 1px #ccc;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        .layer-controls button {
            padding: 4px 8px;
            font-size: 11px;
            min-width: auto;
        }

        .form-group {
            margin-bottom: 15px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f0f0f0;
        }

        .btn-secondary.active {
            background: #667eea;
            color: white;
        }

        .message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .merge-section {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .examples {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .examples h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .example-item {
            margin-bottom: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 11px;
        }

        .example-item:hover {
            background: #e9ecef;
        }

        #map {
            flex: 1;
            position: relative;
        }

        #map.select-mode .mapboxgl-canvas-container {
            cursor: crosshair !important;
        }

        #map.select-mode .mapboxgl-canvas {
            cursor: crosshair !important;
        }

        #map.add-point-mode .mapboxgl-canvas-container {
            cursor: copy !important;
        }

        #map.add-point-mode .mapboxgl-canvas {
            cursor: copy !important;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1;
            min-width: 180px;
        }

        .map-controls select {
            width: 100%;
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 12px;
        }

        .map-controls button {
            width: 100%;
            margin-bottom: 8px;
            padding: 8px 12px;
            font-size: 12px;
        }

        .map-controls button:last-child {
            margin-bottom: 0;
        }

        .map-controls label {
            display: block;
            font-size: 11px;
            margin-bottom: 8px;
            color: #666;
        }

        .map-controls input[type="checkbox"] {
            margin-right: 5px;
        }

        #selectionBox {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
            display: none;
            z-index: 999;
        }

        .temp-point-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #ff4444, 0 2px 8px rgba(0,0,0,0.3);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .stats {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ—ºï¸ PostGIS Multi-Layer Viewer (Optimized)</h1>
        <p>ëŒ€ìš©ëŸ‰ ë°ì´í„° ìµœì í™” - 20ë§Œ í¬ì¸íŠ¸ ì´ìƒ ì§€ì›</p>
    </div>

    <div class="container">
        <div class="input-panel">
            <!-- Layer 1 -->
            <div class="layer-section active" id="layer1-section">
                <div class="layer-header">
                    <div class="layer-title">
                        <div class="layer-color" style="background: #667eea;"></div>
                        <span>Layer 1</span>
                    </div>
                    <div class="layer-controls">
                        <button class="btn-secondary" onclick="toggleLayerVisibility(1)">ğŸ‘ï¸</button>
                        <button class="btn-secondary" onclick="clearLayer(1)">ğŸ—‘ï¸</button>
                    </div>
                </div>
                <div class="form-group">
                    <textarea id="geomInput1" placeholder="LINESTRING(...) ë˜ëŠ” MULTILINESTRING(...)"></textarea>
                    <div class="stats" id="stats1"></div>
                </div>
                <button class="btn-primary" onclick="loadGeometry(1)" style="width: 100%; margin-bottom: 8px;">í‘œì‹œ</button>
                <button class="btn-secondary" onclick="autoConnectPoints(1)" style="width: 100%;">ğŸ”— ìë™ ì—°ê²°</button>
            </div>

            <!-- Layer 2 -->
            <div class="layer-section" id="layer2-section">
                <div class="layer-header">
                    <div class="layer-title">
                        <div class="layer-color" style="background: #f59e0b;"></div>
                        <span>Layer 2</span>
                    </div>
                    <div class="layer-controls">
                        <button class="btn-secondary" onclick="toggleLayerVisibility(2)">ğŸ‘ï¸</button>
                        <button class="btn-secondary" onclick="clearLayer(2)">ğŸ—‘ï¸</button>
                    </div>
                </div>
                <div class="form-group">
                    <textarea id="geomInput2" placeholder="LINESTRING(...) ë˜ëŠ” MULTILINESTRING(...)"></textarea>
                    <div class="stats" id="stats2"></div>
                </div>
                <button class="btn-primary" onclick="loadGeometry(2)" style="width: 100%; margin-bottom: 8px;">í‘œì‹œ</button>
                <button class="btn-secondary" onclick="autoConnectPoints(2)" style="width: 100%;">ğŸ”— ìë™ ì—°ê²°</button>
            </div>

            <!-- Layer 3 -->
            <div class="layer-section" id="layer3-section">
                <div class="layer-header">
                    <div class="layer-title">
                        <div class="layer-color" style="background: #10b981;"></div>
                        <span>Layer 3</span>
                    </div>
                    <div class="layer-controls">
                        <button class="btn-secondary" onclick="toggleLayerVisibility(3)">ğŸ‘ï¸</button>
                        <button class="btn-secondary" onclick="clearLayer(3)">ğŸ—‘ï¸</button>
                    </div>
                </div>
                <div class="form-group">
                    <textarea id="geomInput3" placeholder="LINESTRING(...) ë˜ëŠ” MULTILINESTRING(...)"></textarea>
                    <div class="stats" id="stats3"></div>
                </div>
                <button class="btn-primary" onclick="loadGeometry(3)" style="width: 100%; margin-bottom: 8px;">í‘œì‹œ</button>
                <button class="btn-secondary" onclick="autoConnectPoints(3)" style="width: 100%;">ğŸ”— ìë™ ì—°ê²°</button>
            </div>

            <!-- í•©ì²´ ë²„íŠ¼ -->
            <div class="merge-section">
                <button class="btn-primary" onclick="mergeLayers()" style="width: 100%;">
                    ğŸ”— ëª¨ë“  ë ˆì´ì–´ í•©ì²´ â†’ Layer 1
                </button>
            </div>

            <div id="message" class="message"></div>

            <div class="examples">
                <h3>ğŸ“‹ ì˜ˆì œ ë°ì´í„°</h3>
                <div class="example-item" onclick="loadExampleToLayer(0, 1)">
                    ì˜ˆì œ 1 â†’ Layer 1
                </div>
                <div class="example-item" onclick="loadExampleToLayer(1, 2)">
                    ì˜ˆì œ 2 â†’ Layer 2
                </div>
                <div class="example-item" onclick="loadExampleToLayer(2, 3)">
                    ì˜ˆì œ 3 â†’ Layer 3
                </div>
            </div>
        </div>

        <div id="map">
            <div class="map-controls">
                <select id="activeLayerSelect" onchange="changeActiveLayer()">
                    <option value="1">í¸ì§‘: Layer 1 (íŒŒë‘)</option>
                    <option value="2">í¸ì§‘: Layer 2 (ì£¼í™©)</option>
                    <option value="3">í¸ì§‘: Layer 3 (ì´ˆë¡)</option>
                </select>
                <label>
                    <input type="checkbox" id="showMarkersToggle" onchange="toggleMarkersVisibility()" checked>
                    í¬ì¸íŠ¸ ë§ˆì»¤ í‘œì‹œ
                </label>
                <label>
                    <input type="checkbox" id="splitLineToggle" checked>
                    ì‚­ì œ ì‹œ ë¼ì¸ ë¶„ë¦¬
                </label>
                <button id="addPointModeBtn" class="btn-secondary" onclick="toggleAddPointMode()">
                    â• í¬ì¸íŠ¸ ì¶”ê°€
                </button>
                <button id="selectModeBtn" class="btn-secondary" onclick="toggleSelectMode()">
                    ì„ íƒ ëª¨ë“œ
                </button>
                <button id="deleteBtn" class="btn-primary" onclick="deleteSelectedPoints()" disabled>
                    ì„ íƒ ì‚­ì œ (0)
                </button>
                <button class="btn-secondary" onclick="clearSelection()">
                    ì„ íƒ í•´ì œ
                </button>
            </div>
            <div id="selectionBox"></div>
        </div>
    </div>

    <script>
        // Mapbox ì•¡ì„¸ìŠ¤ í† í°
        mapboxgl.accessToken = 'pk.eyJ1IjoibG9zdGNhZmUwIiwiYSI6ImNsMnBoOHpyMTAyMzczY254MmthZG1rOWEifQ.p_Xuk6AkxC7C9W4CPBwrjA';

        // ì§€ë„ ì´ˆê¸°í™”
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [139.8, 36.0],
            zoom: 10
        });

        map.addControl(new mapboxgl.NavigationControl());

        // ë ˆì´ì–´ ì‹œìŠ¤í…œ (ìµœì í™”: ë§ˆì»¤ ëŒ€ì‹  circle layer ì‚¬ìš©)
        const layers = {
            1: { feature: null, visible: true, color: '#667eea', selected: new Set() },
            2: { feature: null, visible: true, color: '#f59e0b', selected: new Set() },
            3: { feature: null, visible: true, color: '#10b981', selected: new Set() }
        };

        // MULTILINESTRINGì˜ ê° LineStringì— ì ìš©í•  ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const lineColorPalette = [
            '#667eea', // íŒŒë‘
            '#f59e0b', // ì£¼í™©
            '#10b981', // ì´ˆë¡
            '#ef4444', // ë¹¨ê°•
            '#8b5cf6', // ë³´ë¼
            '#ec4899', // í•‘í¬
            '#14b8a6', // ì²­ë¡
            '#f97316', // ì§„í•œ ì£¼í™©
            '#06b6d4', // í•˜ëŠ˜ìƒ‰
            '#84cc16', // ì—°ë‘
            '#f43f5e', // ì¥ë¯¸ìƒ‰
            '#6366f1', // ì¸ë””ê³ 
        ];

        let activeLayer = 1;
        let isSelectMode = false;
        let isAddPointMode = false;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let tempMarkers = [];
        let showMarkers = true;

        const examples = [
            'LINESTRING(126.9780 37.5665, 127.0276 37.4979)',
            'LINESTRING(127.0276 37.4979, 127.0474 37.5048, 127.0636 37.5172)',
            'MULTILINESTRING((126.9780 37.5665, 127.0276 37.4979), (127.0474 37.5048, 127.0636 37.5172))'
        ];

        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 3000);
        }

        function parseWKT(wkt) {
            wkt = wkt.trim();
            
            if (wkt.startsWith('LINESTRING')) {
                const coords = wkt.match(/LINESTRING\s*\(([^)]+)\)/)[1];
                const points = coords.split(',').map(point => {
                    const [lng, lat] = point.trim().split(/\s+/).map(Number);
                    return [lng, lat];
                });
                return {
                    type: 'Feature',
                    geometry: { type: 'LineString', coordinates: points }
                };
            }
            
            if (wkt.startsWith('MULTILINESTRING')) {
                const lineStrings = [];
                const content = wkt.match(/MULTILINESTRING\s*\(\s*(.+)\s*\)/s)[1];
                let depth = 0;
                let currentLine = '';
                
                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    if (char === '(') {
                        depth++;
                        if (depth === 1) continue;
                    } else if (char === ')') {
                        depth--;
                        if (depth === 0) {
                            const points = currentLine.split(',').map(point => {
                                const [lng, lat] = point.trim().split(/\s+/).map(Number);
                                return [lng, lat];
                            });
                            lineStrings.push(points);
                            currentLine = '';
                            continue;
                        }
                    }
                    if (depth > 0) currentLine += char;
                }
                
                return {
                    type: 'Feature',
                    geometry: { type: 'MultiLineString', coordinates: lineStrings }
                };
            }
            
            throw new Error('LINESTRING ë˜ëŠ” MULTILINESTRINGë§Œ ì§€ì›í•©ë‹ˆë‹¤.');
        }

        function loadExampleToLayer(exampleIndex, layerNum) {
            document.getElementById(`geomInput${layerNum}`).value = examples[exampleIndex];
        }

        function changeActiveLayer() {
            const select = document.getElementById('activeLayerSelect');
            activeLayer = parseInt(select.value);
            
            for (let i = 1; i <= 3; i++) {
                const section = document.getElementById(`layer${i}-section`);
                if (i === activeLayer) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            }
            
            clearSelection();
            updatePointsLayer();
        }

        function toggleLayerVisibility(layerNum) {
            const layer = layers[layerNum];
            layer.visible = !layer.visible;
            
            const layerId = `route-layer-${layerNum}`;
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', layer.visible ? 'visible' : 'none');
            }
            
            updatePointsLayer();
        }

        function toggleMarkersVisibility() {
            showMarkers = document.getElementById('showMarkersToggle').checked;
            updatePointsLayer();
        }

        function clearLayer(layerNum) {
            const layer = layers[layerNum];
            
            const layerId = `route-layer-${layerNum}`;
            if (map.getLayer(layerId)) map.removeLayer(layerId);
            if (map.getSource(`route-${layerNum}`)) map.removeSource(`route-${layerNum}`);
            
            layer.selected.clear();
            layer.feature = null;
            
            document.getElementById(`geomInput${layerNum}`).value = '';
            document.getElementById(`stats${layerNum}`).textContent = '';
            updateDeleteButton();
            updatePointsLayer();
            
            if (layerNum === activeLayer && isAddPointMode) {
                toggleAddPointMode();
            }
            
            showMessage(`Layer ${layerNum} ì‚­ì œë¨`, 'success');
        }

        function loadGeometry(layerNum) {
            const geomInput = document.getElementById(`geomInput${layerNum}`).value.trim();

            if (!geomInput) {
                showMessage('Geometry ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”', 'error');
                return;
            }

            try {
                const feature = parseWKT(geomInput);
                const layer = layers[layerNum];
                layer.feature = feature;

                const layerId = `route-layer-${layerNum}`;
                const sourceId = `route-${layerNum}`;

                if (map.getLayer(layerId)) map.removeLayer(layerId);
                if (map.getSource(sourceId)) map.removeSource(sourceId);

                // MULTILINESTRINGì˜ ê²½ìš° ê° LineStringì„ ë³„ë„ì˜ featureë¡œ ë¶„ë¦¬í•˜ì—¬ ë‹¤ë¥¸ ìƒ‰ìƒ ì ìš©
                let sourceData;
                let linePaint;

                if (feature.geometry.type === 'MultiLineString') {
                    // ê° LineStringì„ ë³„ë„ì˜ featureë¡œ ë§Œë“¤ì–´ FeatureCollection ìƒì„±
                    const features = feature.geometry.coordinates.map((lineCoords, index) => ({
                        type: 'Feature',
                        properties: {
                            lineIndex: index,
                            color: lineColorPalette[index % lineColorPalette.length]
                        },
                        geometry: {
                            type: 'LineString',
                            coordinates: lineCoords
                        }
                    }));

                    sourceData = {
                        type: 'FeatureCollection',
                        features: features
                    };

                    // data-driven stylingìœ¼ë¡œ ê° lineIndexì— ë”°ë¼ ë‹¤ë¥¸ ìƒ‰ìƒ ì ìš©
                    linePaint = {
                        'line-color': ['get', 'color'],
                        'line-width': 4,
                        'line-opacity': 0.8
                    };
                } else {
                    // LINESTRINGì˜ ê²½ìš° ê¸°ì¡´ê³¼ ë™ì¼í•˜ê²Œ ë‹¨ì¼ ìƒ‰ìƒ
                    sourceData = feature;
                    linePaint = {
                        'line-color': layer.color,
                        'line-width': 4,
                        'line-opacity': 0.8
                    };
                }

                map.addSource(sourceId, {
                    type: 'geojson',
                    data: sourceData
                });

                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: linePaint
                });

                updatePointsLayer();

                const geometryType = feature.geometry.type;
                let pointCount = 0, lineCount = 1;

                if (geometryType === 'LineString') {
                    pointCount = feature.geometry.coordinates.length;
                } else {
                    lineCount = feature.geometry.coordinates.length;
                    pointCount = feature.geometry.coordinates.reduce((sum, line) => sum + line.length, 0);
                }

                document.getElementById(`stats${layerNum}`).textContent =
                    `${lineCount}ë¼ì¸, ${pointCount}í¬ì¸íŠ¸`;

                showMessage(`Layer ${layerNum}: ${geometryType} ë¡œë“œ ì™„ë£Œ`, 'success');
            } catch (error) {
                showMessage(`ì˜¤ë¥˜: ${error.message}`, 'error');
            }
        }

        // ìµœì í™”: ëª¨ë“  í¬ì¸íŠ¸ë¥¼ í•˜ë‚˜ì˜ circle layerë¡œ í‘œì‹œ
        function updatePointsLayer() {
            // ê¸°ì¡´ í¬ì¸íŠ¸ ë ˆì´ì–´ ì œê±°
            if (map.getLayer('all-points-layer')) map.removeLayer('all-points-layer');
            if (map.getLayer('selected-points-layer')) map.removeLayer('selected-points-layer');
            if (map.getSource('all-points')) map.removeSource('all-points');
            if (map.getSource('selected-points')) map.removeSource('selected-points');

            if (!showMarkers) return;

            const allPoints = [];
            const selectedPoints = [];

            [1, 2, 3].forEach(layerNum => {
                const layer = layers[layerNum];
                if (!layer.feature || !layer.visible) return;

                if (layer.feature.geometry.type === 'LineString') {
                    // LINESTRING: ê¸°ì¡´ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
                    layer.feature.geometry.coordinates.forEach((coord, idx) => {
                        const pointFeature = {
                            type: 'Feature',
                            geometry: { type: 'Point', coordinates: coord },
                            properties: {
                                layerNum: layerNum,
                                index: idx,
                                color: layer.color,
                                coords: `${coord[0].toFixed(12)}, ${coord[1].toFixed(12)}`
                            }
                        };

                        allPoints.push(pointFeature);

                        if (layerNum === activeLayer) {
                            const key = `${idx}`;
                            if (layer.selected.has(key)) {
                                selectedPoints.push(pointFeature);
                            }
                        }
                    });
                } else {
                    // MULTILINESTRING: ê° LineStringë§ˆë‹¤ ë‹¤ë¥¸ ìƒ‰ìƒ ì ìš©
                    let flatIndex = 0;
                    layer.feature.geometry.coordinates.forEach((lineCoords, lineIndex) => {
                        const lineColor = lineColorPalette[lineIndex % lineColorPalette.length];

                        lineCoords.forEach((coord, pointIdx) => {
                            const pointFeature = {
                                type: 'Feature',
                                geometry: { type: 'Point', coordinates: coord },
                                properties: {
                                    layerNum: layerNum,
                                    index: flatIndex,
                                    lineIndex: lineIndex,
                                    color: lineColor,
                                    coords: `${coord[0].toFixed(12)}, ${coord[1].toFixed(12)}`
                                }
                            };

                            allPoints.push(pointFeature);

                            if (layerNum === activeLayer) {
                                const key = `${flatIndex}`;
                                if (layer.selected.has(key)) {
                                    selectedPoints.push(pointFeature);
                                }
                            }

                            flatIndex++;
                        });
                    });
                }
            });

            if (allPoints.length > 0) {
                map.addSource('all-points', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: allPoints
                    }
                });

                map.addLayer({
                    id: 'all-points-layer',
                    type: 'circle',
                    source: 'all-points',
                    paint: {
                        'circle-radius': 4,
                        'circle-color': ['get', 'color'],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });

                // í¬ì¸íŠ¸ í´ë¦­ ì´ë²¤íŠ¸
                map.on('click', 'all-points-layer', (e) => {
                    if (isAddPointMode || isSelectMode) return;
                    
                    const coords = e.features[0].properties.coords;
                    navigator.clipboard.writeText(coords).then(() => {
                        showMessage(`ë³µì‚¬ë¨: ${coords}`, 'success');
                    });
                });

                // í˜¸ë²„ ì»¤ì„œ
                map.on('mouseenter', 'all-points-layer', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'all-points-layer', () => {
                    map.getCanvas().style.cursor = '';
                });
            }

            if (selectedPoints.length > 0) {
                map.addSource('selected-points', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: selectedPoints
                    }
                });

                map.addLayer({
                    id: 'selected-points-layer',
                    type: 'circle',
                    source: 'selected-points',
                    paint: {
                        'circle-radius': 6,
                        'circle-color': '#ff4444',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });
            }
        }

        function mergeLayers() {
            const activeLayers = [1, 2, 3].filter(num => layers[num].feature !== null);
            
            if (activeLayers.length < 2) {
                showMessage('ìµœì†Œ 2ê°œ ë ˆì´ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤', 'error');
                return;
            }
            
            const allLines = [];
            activeLayers.forEach(num => {
                const feature = layers[num].feature;
                if (feature.geometry.type === 'LineString') {
                    allLines.push(feature.geometry.coordinates);
                } else {
                    allLines.push(...feature.geometry.coordinates);
                }
            });
            
            const wkt = `MULTILINESTRING(${allLines.map(line => 
                `(${line.map(c => `${c[0]} ${c[1]}`).join(', ')})`
            ).join(', ')})`;
            
            document.getElementById('geomInput1').value = wkt;
            
            activeLayers.slice(1).forEach(num => clearLayer(num));
            loadGeometry(1);
            
            showMessage(`${activeLayers.length}ê°œ ë ˆì´ì–´ê°€ í•©ì²´ë¨`, 'success');
        }

        function toggleSelectMode() {
            isSelectMode = !isSelectMode;
            const btn = document.getElementById('selectModeBtn');
            const mapElement = document.getElementById('map');
            
            if (isSelectMode) {
                if (isAddPointMode) toggleAddPointMode();
                
                btn.classList.add('active');
                btn.textContent = 'ì„ íƒ ëª¨ë“œ (ON)';
                mapElement.classList.add('select-mode');
                
                map.dragPan.disable();
                map.scrollZoom.disable();
                map.boxZoom.disable();
                map.dragRotate.disable();
                map.keyboard.disable();
                map.doubleClickZoom.disable();
                map.touchZoomRotate.disable();
            } else {
                btn.classList.remove('active');
                btn.textContent = 'ì„ íƒ ëª¨ë“œ';
                mapElement.classList.remove('select-mode');
                
                map.dragPan.enable();
                map.scrollZoom.enable();
                map.boxZoom.enable();
                map.dragRotate.enable();
                map.keyboard.enable();
                map.doubleClickZoom.enable();
                map.touchZoomRotate.enable();
                clearSelection();
            }
        }

        function toggleAddPointMode() {
            isAddPointMode = !isAddPointMode;
            const btn = document.getElementById('addPointModeBtn');
            const mapElement = document.getElementById('map');
            
            if (isAddPointMode) {
                if (isSelectMode) toggleSelectMode();
                
                btn.classList.add('active');
                btn.textContent = 'â• ì¶”ê°€ ëª¨ë“œ (ON)';
                mapElement.classList.add('add-point-mode');
                
                map.dragPan.disable();
                map.boxZoom.disable();
                map.dragRotate.disable();
                map.doubleClickZoom.disable();
                
                showMessage('ì§€ë„ë¥¼ í´ë¦­í•˜ì—¬ í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ì„¸ìš”', 'success');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'â• í¬ì¸íŠ¸ ì¶”ê°€';
                mapElement.classList.remove('add-point-mode');
                
                map.dragPan.enable();
                map.boxZoom.enable();
                map.dragRotate.enable();
                map.doubleClickZoom.enable();
                
                tempMarkers.forEach(marker => marker.remove());
                tempMarkers = [];
            }
        }

        function clearSelection() {
            const layer = layers[activeLayer];
            layer.selected.clear();
            updateDeleteButton();
            updatePointsLayer();
        }

        function updateDeleteButton() {
            const deleteBtn = document.getElementById('deleteBtn');
            const count = layers[activeLayer].selected.size;
            deleteBtn.textContent = `ì„ íƒ ì‚­ì œ (${count})`;
            deleteBtn.disabled = count === 0;
        }

        function distance(p1, p2) {
            const dx = p1[0] - p2[0];
            const dy = p1[1] - p2[1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        function distanceToSegment(point, segStart, segEnd) {
            const x = point[0], y = point[1];
            const x1 = segStart[0], y1 = segStart[1];
            const x2 = segEnd[0], y2 = segEnd[1];
            
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq != 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = x - xx;
            const dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function insertPointIntoLineString(coordinates, newPoint) {
            if (coordinates.length < 2) {
                coordinates.push(newPoint);
                return;
            }
            
            let minDistance = Infinity;
            let insertIndex = coordinates.length;
            
            for (let i = 0; i < coordinates.length - 1; i++) {
                const dist = distanceToSegment(newPoint, coordinates[i], coordinates[i + 1]);
                if (dist < minDistance) {
                    minDistance = dist;
                    insertIndex = i + 1;
                }
            }
            
            coordinates.splice(insertIndex, 0, newPoint);
        }

        // ì§€ë„ í´ë¦­ìœ¼ë¡œ í¬ì¸íŠ¸ ì¶”ê°€
        map.on('click', (e) => {
            if (!isAddPointMode) return;
            
            const layer = layers[activeLayer];
            if (!layer.feature) {
                showMessage('ë¨¼ì € ë ˆì´ì–´ì— geometryë¥¼ ë¡œë“œí•˜ì„¸ìš”', 'error');
                return;
            }
            
            const lngLat = e.lngLat;
            const newPoint = [lngLat.lng, lngLat.lat];
            
            const el = document.createElement('div');
            el.className = 'temp-point-marker';
            el.style.background = layer.color;
            const tempMarker = new mapboxgl.Marker({ element: el })
                .setLngLat(newPoint)
                .addTo(map);
            tempMarkers.push(tempMarker);
            
            if (layer.feature.geometry.type === 'LineString') {
                insertPointIntoLineString(layer.feature.geometry.coordinates, newPoint);
            } else if (layer.feature.geometry.type === 'MultiLineString') {
                let minDistance = Infinity;
                let targetLineIndex = 0;
                let targetSegmentIndex = 0;
                
                layer.feature.geometry.coordinates.forEach((line, lineIdx) => {
                    for (let i = 0; i < line.length - 1; i++) {
                        const dist = distanceToSegment(newPoint, line[i], line[i + 1]);
                        if (dist < minDistance) {
                            minDistance = dist;
                            targetLineIndex = lineIdx;
                            targetSegmentIndex = i;
                        }
                    }
                });
                
                layer.feature.geometry.coordinates[targetLineIndex].splice(targetSegmentIndex + 1, 0, newPoint);
            }
            
            if (map.getSource(`route-${activeLayer}`)) {
                map.getSource(`route-${activeLayer}`).setData(layer.feature);
            }
            
            updatePointsLayer();
            updateWKTInput(activeLayer);
            updateStats(activeLayer);
            
            showMessage(`í¬ì¸íŠ¸ ì¶”ê°€ë¨`, 'success');
        });

        function deleteSelectedPoints() {
            const layer = layers[activeLayer];
            if (layer.selected.size === 0 || !layer.feature) return;

            const splitLine = document.getElementById('splitLineToggle').checked;
            const selectedIndices = Array.from(layer.selected).map(key => parseInt(key)).sort((a, b) => a - b);

            if (layer.feature.geometry.type === 'LineString') {
                const coords = layer.feature.geometry.coordinates;
                
                if (splitLine) {
                    // ë¼ì¸ì„ ë¶„ë¦¬í•˜ëŠ” ë°©ì‹
                    const newLines = [];
                    let currentLine = [];
                    
                    for (let i = 0; i < coords.length; i++) {
                        if (selectedIndices.includes(i)) {
                            // ì‚­ì œí•  í¬ì¸íŠ¸ - í˜„ì¬ ë¼ì¸ì„ ì €ì¥í•˜ê³  ìƒˆ ë¼ì¸ ì‹œì‘
                            if (currentLine.length > 1) {
                                newLines.push([...currentLine]);
                            }
                            currentLine = [];
                        } else {
                            currentLine.push(coords[i]);
                        }
                    }
                    
                    // ë§ˆì§€ë§‰ ë¼ì¸ ì €ì¥
                    if (currentLine.length > 1) {
                        newLines.push(currentLine);
                    }
                    
                    // MULTILINESTRINGìœ¼ë¡œ ë³€í™˜
                    if (newLines.length === 0) {
                        showMessage('ëª¨ë“  í¬ì¸íŠ¸ë¥¼ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                        return;
                    } else if (newLines.length === 1) {
                        layer.feature.geometry.coordinates = newLines[0];
                    } else {
                        layer.feature.geometry.type = 'MultiLineString';
                        layer.feature.geometry.coordinates = newLines;
                    }
                } else {
                    // ë‹¨ìˆœíˆ í¬ì¸íŠ¸ë§Œ ì‚­ì œ (ì—°ê²° ìœ ì§€)
                    selectedIndices.reverse().forEach(idx => {
                        coords.splice(idx, 1);
                    });
                    
                    if (coords.length < 2) {
                        showMessage('ìµœì†Œ 2ê°œì˜ í¬ì¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤', 'error');
                        return;
                    }
                }
            } else if (layer.feature.geometry.type === 'MultiLineString') {
                // ì „ì²´ ì¢Œí‘œë¥¼ flatí•˜ê²Œ ë§Œë“¤ê³  ì¸ë±ìŠ¤ ë§¤í•‘
                let flatIndex = 0;
                const lineMapping = [];
                
                layer.feature.geometry.coordinates.forEach((line, lineIdx) => {
                    line.forEach((coord, pointIdx) => {
                        lineMapping.push({ lineIdx, pointIdx, flatIndex });
                        flatIndex++;
                    });
                });
                
                if (splitLine) {
                    // ê° ë¼ì¸ë³„ë¡œ ì²˜ë¦¬
                    const newLines = [];
                    
                    layer.feature.geometry.coordinates.forEach((line, lineIdx) => {
                        const lineSelectedIndices = [];
                        
                        lineMapping.forEach(mapping => {
                            if (mapping.lineIdx === lineIdx && selectedIndices.includes(mapping.flatIndex)) {
                                lineSelectedIndices.push(mapping.pointIdx);
                            }
                        });
                        
                        if (lineSelectedIndices.length === 0) {
                            // ì´ ë¼ì¸ì—ì„œ ì‚­ì œí•  í¬ì¸íŠ¸ê°€ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
                            newLines.push([...line]);
                        } else {
                            // ì´ ë¼ì¸ì„ ë¶„ë¦¬
                            let currentLine = [];
                            
                            for (let i = 0; i < line.length; i++) {
                                if (lineSelectedIndices.includes(i)) {
                                    if (currentLine.length > 1) {
                                        newLines.push([...currentLine]);
                                    }
                                    currentLine = [];
                                } else {
                                    currentLine.push(line[i]);
                                }
                            }
                            
                            if (currentLine.length > 1) {
                                newLines.push(currentLine);
                            }
                        }
                    });
                    
                    if (newLines.length === 0) {
                        showMessage('ëª¨ë“  í¬ì¸íŠ¸ë¥¼ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                        return;
                    }
                    
                    layer.feature.geometry.coordinates = newLines;
                } else {
                    // ë‹¨ìˆœíˆ í¬ì¸íŠ¸ë§Œ ì‚­ì œ
                    const toDelete = new Set(selectedIndices);
                    const newLines = [];
                    
                    let currentFlatIndex = 0;
                    layer.feature.geometry.coordinates.forEach(line => {
                        const newLine = [];
                        line.forEach(coord => {
                            if (!toDelete.has(currentFlatIndex)) {
                                newLine.push(coord);
                            }
                            currentFlatIndex++;
                        });
                        if (newLine.length > 1) {
                            newLines.push(newLine);
                        }
                    });
                    
                    if (newLines.length === 0) {
                        showMessage('ìµœì†Œ 2ê°œì˜ í¬ì¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤', 'error');
                        return;
                    }
                    
                    layer.feature.geometry.coordinates = newLines;
                }
            }

            if (map.getSource(`route-${activeLayer}`)) {
                map.getSource(`route-${activeLayer}`).setData(layer.feature);
            }

            const deletedCount = selectedIndices.length;
            clearSelection();
            updatePointsLayer();
            updateWKTInput(activeLayer);
            updateStats(activeLayer);

            const message = splitLine 
                ? `${deletedCount}ê°œ í¬ì¸íŠ¸ ì‚­ì œ + ë¼ì¸ ë¶„ë¦¬ë¨`
                : `${deletedCount}ê°œ í¬ì¸íŠ¸ ì‚­ì œë¨ (ì—°ê²° ìœ ì§€)`;
            showMessage(message, 'success');
        }

        function updateWKTInput(layerNum) {
            const feature = layers[layerNum].feature;
            let wkt = '';
            
            if (feature.geometry.type === 'LineString') {
                const coords = feature.geometry.coordinates.map(c => `${c[0]} ${c[1]}`).join(', ');
                wkt = `LINESTRING(${coords})`;
            } else {
                const lines = feature.geometry.coordinates.map(line => {
                    const coords = line.map(c => `${c[0]} ${c[1]}`).join(', ');
                    return `(${coords})`;
                }).join(', ');
                wkt = `MULTILINESTRING(${lines})`;
            }
            
            document.getElementById(`geomInput${layerNum}`).value = wkt;
        }

        function updateStats(layerNum) {
            const feature = layers[layerNum].feature;
            if (!feature) return;

            const geometryType = feature.geometry.type;
            let pointCount = 0, lineCount = 1;
            
            if (geometryType === 'LineString') {
                pointCount = feature.geometry.coordinates.length;
            } else {
                lineCount = feature.geometry.coordinates.length;
                pointCount = feature.geometry.coordinates.reduce((sum, line) => sum + line.length, 0);
            }
            
            document.getElementById(`stats${layerNum}`).textContent = 
                `${lineCount}ë¼ì¸, ${pointCount}í¬ì¸íŠ¸`;
        }

        // ìë™ ì—°ê²° í•¨ìˆ˜ - Nearest Neighbor ì•Œê³ ë¦¬ì¦˜
        function autoConnectPoints(layerNum) {
            const layer = layers[layerNum];
            if (!layer.feature) {
                showMessage('ë¨¼ì € ë ˆì´ì–´ì— geometryë¥¼ ë¡œë“œí•˜ì„¸ìš”', 'error');
                return;
            }

            // ëª¨ë“  í¬ì¸íŠ¸ë¥¼ ì¶”ì¶œ
            let allPoints = [];
            if (layer.feature.geometry.type === 'LineString') {
                allPoints = [...layer.feature.geometry.coordinates];
            } else {
                layer.feature.geometry.coordinates.forEach(line => {
                    allPoints.push(...line);
                });
            }

            if (allPoints.length < 2) {
                showMessage('ìµœì†Œ 2ê°œì˜ í¬ì¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤', 'error');
                return;
            }

            // Nearest Neighborë¡œ ì •ë ¬
            const sortedPoints = nearestNeighborSort(allPoints);

            // LINESTRINGìœ¼ë¡œ ë³€í™˜
            layer.feature.geometry.type = 'LineString';
            layer.feature.geometry.coordinates = sortedPoints;

            // ì§€ë„ ì—…ë°ì´íŠ¸
            if (map.getSource(`route-${layerNum}`)) {
                map.getSource(`route-${layerNum}`).setData(layer.feature);
            }

            updatePointsLayer();
            updateWKTInput(layerNum);
            updateStats(layerNum);

            showMessage(`Layer ${layerNum}: ${allPoints.length}ê°œ í¬ì¸íŠ¸ê°€ ìë™ ì—°ê²°ë¨`, 'success');
        }

        // Nearest Neighbor ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
        function nearestNeighborSort(points) {
            if (points.length === 0) return [];
            
            const result = [];
            const remaining = [...points];
            
            // ì²« ë²ˆì§¸ í¬ì¸íŠ¸ë¥¼ ì‹œì‘ì ìœ¼ë¡œ
            let current = remaining.shift();
            result.push(current);
            
            // ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ë¥¼ ë°˜ë³µì ìœ¼ë¡œ ì°¾ê¸°
            while (remaining.length > 0) {
                let minDist = Infinity;
                let minIndex = 0;
                
                for (let i = 0; i < remaining.length; i++) {
                    const dist = distance(current, remaining[i]);
                    if (dist < minDist) {
                        minDist = dist;
                        minIndex = i;
                    }
                }
                
                current = remaining.splice(minIndex, 1)[0];
                result.push(current);
            }
            
            return result;
        }

        // ë“œë˜ê·¸ ì„ íƒ (ìµœì í™”: queryRenderedFeatures ì‚¬ìš©)
        const mapContainer = map.getContainer();
        
        mapContainer.addEventListener('mousedown', (e) => {
            if (!isSelectMode) return;
            if (e.target.closest('.map-controls')) return;
            
            e.preventDefault();
            e.stopPropagation();

            isDragging = true;
            const rect = mapContainer.getBoundingClientRect();
            dragStart = { 
                x: e.clientX - rect.left, 
                y: e.clientY - rect.top,
                screenX: e.clientX,
                screenY: e.clientY
            };

            const selectionBox = document.getElementById('selectionBox');
            selectionBox.style.left = e.clientX + 'px';
            selectionBox.style.top = e.clientY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
        }, true);

        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !isSelectMode) return;
            
            e.preventDefault();
            e.stopPropagation();

            const selectionBox = document.getElementById('selectionBox');
            const width = Math.abs(e.clientX - dragStart.screenX);
            const height = Math.abs(e.clientY - dragStart.screenY);
            const left = Math.min(e.clientX, dragStart.screenX);
            const top = Math.min(e.clientY, dragStart.screenY);

            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
        });

        document.addEventListener('mouseup', (e) => {
            if (!isDragging || !isSelectMode) return;
            
            e.preventDefault();
            e.stopPropagation();

            const selectionBox = document.getElementById('selectionBox');
            selectionBox.style.display = 'none';

            const width = Math.abs(e.clientX - dragStart.screenX);
            const height = Math.abs(e.clientY - dragStart.screenY);
            
            if (width > 3 || height > 3) {
                const rect = mapContainer.getBoundingClientRect();
                const x1 = Math.min(dragStart.x, e.clientX - rect.left);
                const y1 = Math.min(dragStart.y, e.clientY - rect.top);
                const x2 = Math.max(dragStart.x, e.clientX - rect.left);
                const y2 = Math.max(dragStart.y, e.clientY - rect.top);

                const layer = layers[activeLayer];

                if (!e.shiftKey) {
                    layer.selected.clear();
                }

                // ìµœì í™”: queryRenderedFeatures ì‚¬ìš©
                const features = map.queryRenderedFeatures(
                    [[x1, y1], [x2, y2]],
                    { layers: ['all-points-layer'] }
                );

                features.forEach(feature => {
                    if (feature.properties.layerNum === activeLayer) {
                        layer.selected.add(feature.properties.index.toString());
                    }
                });

                updateDeleteButton();
                updatePointsLayer();
            }

            isDragging = false;
        });
    </script>
</body>
</html>
